在一个多人协作的大型项目中，基础库的研发工程师小明提供了一个接口调用，完整定义如下：

```javascript
function showInput(input) {
  return input.show();
}
```

基础库的API往往以函数签名的形式提供给业务方调用，此时作为业务调用方的小红，在业务代码中作出调用：

```javascript
// 在javascript中调用报错
// Uncaught TypeError: input.show is not a function
showInput("hello world");
```

上述示例中，我们一眼就可以看出错误，因为函数定义显示出来并且函数体很简单！但实际情况中函数往往比较复杂，大部分甚至根本不会去阅读函数体的源码，函数体对于调用者而言是一个黑盒，我们需要的仅仅是签名`showInput(input)`而已，而`JavaScript`函数签名并不能够直接告诉你：**函数的唯一参数具体有什么要求**。在不了解更多信息的情况下错误的调用会成为大概率事件。


在`JavaScript`中，如果一段包含错误的代码需要用户产生交互行为之后才会执行触发，开发阶段大概率完全感知不到错误的存在，因为不存在预发错误，编辑器往往不会提示你。


在`TypeScript`中，为了解决这个问题，我们为 `input` 参数提供了**类型描述 `InputType`**

```typescript
// InputType描述了一个包含show方法的类型
type InputType = {
  show: ()=>void;
};
// 此时函数的签名带有参数类型了
showInput(input: InputType);
```

当你用同样的方式在 `TypeScript` 中调用 `showInput("hello world")`，一旦执行编译，编译器就会提示你存在错误

```typescript
// 以下代码在typescript中调用报错
// error TS2345: Argument of type '"hello world"' is not assignable to parameter of type 'InputType'.
showInput("hello world");
```

在支持`TypeScript`语言的大部分代码编辑器（如`vscode`）中，`InputType` 类型在编码阶段就被正确的智能提示出来，改成正确版本：

```typescript
// 定义input变量，包含show方法
const input = {
  show(){
    return "hello world"
  }
}
// 将包含show的变量传递给函数
showInput(input);
```

这是到目前为止，这是JavaScript需要强制类型的最好理由，它可以**让绝大部分的错误在编码阶段被发现，而不是让错误发生在线上**！

